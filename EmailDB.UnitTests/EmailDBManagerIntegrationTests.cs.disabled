using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using EmailDB.Format;
using EmailDB.Format.FileManagement;
using EmailDB.Format.Models;
using EmailDB.Format.Models.BlockTypes;
using EmailDB.Format.Helpers;
using Xunit;
using Xunit.Abstractions;

namespace EmailDB.UnitTests;

/// <summary>
/// Integration tests for EmailDB managers including:
/// - CacheManager
/// - MetadataManager
/// - FolderManager
/// - SegmentManager
/// - MaintenanceManager
/// </summary>
public class EmailDBManagerIntegrationTests : IDisposable
{
    private readonly string _testDirectory;
    private readonly string _testFile;
    private readonly RawBlockManager _rawBlockManager;
    private readonly CacheManager _cacheManager;
    private readonly MetadataManager _metadataManager;
    private readonly FolderManager _folderManager;
    private readonly SegmentManager _segmentManager;
    // private readonly MaintenanceManager _maintenanceManager; // Commented out in the source
    private readonly ITestOutputHelper _output;

    public EmailDBManagerIntegrationTests(ITestOutputHelper output)
    {
        _output = output;
        _testDirectory = Path.Combine(Path.GetTempPath(), $"EmailDBManagerTest_{Guid.NewGuid()}");
        Directory.CreateDirectory(_testDirectory);
        _testFile = Path.Combine(_testDirectory, "test.emdb");
        
        _rawBlockManager = new RawBlockManager(_testFile);
        var serializer = new DefaultBlockContentSerializer();
        _cacheManager = new CacheManager(_rawBlockManager, serializer);
        _metadataManager = new MetadataManager(_cacheManager);
        _folderManager = new FolderManager(_cacheManager, _metadataManager);
        _segmentManager = new SegmentManager(_cacheManager, _metadataManager);
        // _maintenanceManager = new MaintenanceManager(_cacheManager, _metadataManager); // Not available
    }

    #region CacheManager Tests

    [Fact]
    public async Task CacheManager_Should_Cache_Frequently_Accessed_Blocks()
    {
        // Arrange
        var binaryData = new byte[1024];
        new Random(42).NextBytes(binaryData);
        
        var segment = new SegmentContent
        {
            SegmentId = 1001,
            SegmentData = binaryData,
            ContentLength = binaryData.Length,
            SegmentTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            Version = 1
        };

        // Act - Write and read multiple times
        await _cacheManager.UpdateSegment("1001", segment);
        
        var read1 = await _cacheManager.GetSegmentAsync(1001);
        var read2 = await _cacheManager.GetSegmentAsync(1001);
        var read3 = await _cacheManager.GetSegmentAsync(1001);

        // Assert
        Assert.NotNull(read1);
        Assert.NotNull(read2);
        Assert.NotNull(read3);
        Assert.Equal(binaryData, read3.SegmentData);
        
        _output.WriteLine("CacheManager successfully cached frequently accessed segment");
    }

    [Fact]
    public async Task CacheManager_Should_Update_Metadata_Block()
    {
        // Arrange
        var metadata = new MetadataContent
        {
            Version = 1,
            CreatedTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            LastModifiedTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            BlockCount = 10,
            FileSize = 1024,
            Properties = new Dictionary<string, string>
            {
                ["TestKey"] = "TestValue"
            }
        };

        // Act
        var result = await _cacheManager.UpdateMetadata(metadata);

        // Assert
        Assert.True(result > 0);
        
        var readMetadata = await _cacheManager.GetMetadataAsync();
        Assert.NotNull(readMetadata);
        // Just verify metadata is not null for now
        // Actual properties depend on MetadataContent structure
        
        _output.WriteLine($"Metadata block written at offset {result}");
    }

    [Fact]
    public async Task CacheManager_Should_Handle_Cache_Invalidation()
    {
        // Arrange
        var originalData = new byte[128];
        new Random(123).NextBytes(originalData);
        
        var segment = new SegmentContent
        {
            SegmentId = 2001,
            SegmentData = originalData,
            ContentLength = originalData.Length,
            SegmentTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            Version = 1
        };

        await _cacheManager.UpdateSegment("2001", segment);
        
        // Act - Invalidate cache and update
        _cacheManager.InvalidateCache();
        
        var updatedData = new byte[256];
        new Random(456).NextBytes(updatedData);
        
        segment.SegmentData = updatedData;
        segment.ContentLength = updatedData.Length;
        segment.Version = 2;
        await _cacheManager.UpdateSegment("2001", segment);

        // Assert
        var updated = await _cacheManager.GetSegmentAsync(2001);
        Assert.NotNull(updated);
        Assert.Equal(updatedData, updated.SegmentData);
        Assert.Equal(2, updated.Version);
        
        _output.WriteLine("Cache invalidation and update successful");
    }

    #endregion

    #region MetadataManager Tests

    [Fact]
    public async Task MetadataManager_Should_Track_Segment_Offsets()
    {
        // Arrange & Act
        await _metadataManager.AddOrUpdateSegmentOffsetAsync("seg1", 100);
        await _metadataManager.AddOrUpdateSegmentOffsetAsync("seg2", 200);
        await _metadataManager.AddOrUpdateSegmentOffsetAsync("seg3", 300);

        var allOffsets = await _metadataManager.GetAllSegmentOffsetsAsync();

        // Assert
        Assert.Equal(3, allOffsets.Count);
        Assert.Equal(100, allOffsets["seg1"]);
        Assert.Equal(200, allOffsets["seg2"]);
        Assert.Equal(300, allOffsets["seg3"]);
        
        _output.WriteLine($"MetadataManager tracking {allOffsets.Count} segment offsets");
    }

    [Fact]
    public async Task MetadataManager_Should_Track_Outdated_Segments()
    {
        // Arrange
        await _metadataManager.AddOrUpdateSegmentOffsetAsync("old1", 100);
        await _metadataManager.AddOrUpdateSegmentOffsetAsync("old2", 200);
        await _metadataManager.AddOrUpdateSegmentOffsetAsync("current", 300);

        // Act
        await _metadataManager.MarkSegmentOutdatedAsync("old1");
        await _metadataManager.MarkSegmentOutdatedAsync("old2");

        var outdated = await _metadataManager.GetOutdatedSegmentOffsetsAsync();

        // Assert
        Assert.Contains(100L, outdated);
        Assert.Contains(200L, outdated);
        Assert.DoesNotContain(300L, outdated);
        
        _output.WriteLine($"Marked {outdated.Count} segments as outdated");
    }

    [Fact]
    public async Task MetadataManager_Should_Cleanup_Outdated_Segments()
    {
        // Arrange
        await _metadataManager.AddOrUpdateSegmentOffsetAsync("cleanup1", 400);
        await _metadataManager.AddOrUpdateSegmentOffsetAsync("cleanup2", 500);
        await _metadataManager.MarkSegmentOutdatedAsync("cleanup1");
        await _metadataManager.MarkSegmentOutdatedAsync("cleanup2");

        // Act
        await _metadataManager.CleanupOutdatedSegmentsAsync();
        
        var outdated = await _metadataManager.GetOutdatedSegmentOffsetsAsync();
        var allOffsets = await _metadataManager.GetAllSegmentOffsetsAsync();

        // Assert
        Assert.Empty(outdated);
        Assert.DoesNotContain("cleanup1", allOffsets.Keys);
        Assert.DoesNotContain("cleanup2", allOffsets.Keys);
        
        _output.WriteLine("Cleanup of outdated segments completed");
    }

    #endregion

    #region FolderManager Tests

    [Fact]
    public async Task FolderManager_Should_Create_And_Manage_Folders()
    {
        // Arrange & Act
        var result1 = await _folderManager.CreateFolderAsync("Inbox");
        var result2 = await _folderManager.CreateFolderAsync("Sent");
        var result3 = await _folderManager.CreateFolderAsync("Drafts");

        // Get folder tree to check folders
        var folderTree = await _cacheManager.GetCachedFolderTree();
        var folders = folderTree?.FolderIDs ?? new Dictionary<string, long>();

        // Assert
        Assert.True(result1.IsSuccess);
        Assert.True(result2.IsSuccess);
        Assert.True(result3.IsSuccess);
        Assert.Equal(3, folders.Count);
        Assert.Contains("Inbox", folders.Keys);
        Assert.Contains("Sent", folders.Keys);
        Assert.Contains("Drafts", folders.Keys);
        
        _output.WriteLine($"Created {folders.Count} folders successfully");
    }

    [Fact]
    public async Task FolderManager_Should_Add_Emails_To_Folders()
    {
        // Arrange
        await _folderManager.CreateFolderAsync("TestFolder");
        
        var emailIds = new List<EmailHashedID>();
        for (int i = 1; i <= 5; i++)
        {
            var bytes = new byte[32];
            BitConverter.GetBytes((long)(5000 + i)).CopyTo(bytes, 0);
            emailIds.Add(new EmailHashedID(bytes));
        }

        // Act
        foreach (var emailId in emailIds)
        {
            var result = await _folderManager.AddEmailToFolderAsync("TestFolder", emailId);
            Assert.True(result.IsSuccess);
        }

        var folderEmails = await _folderManager.GetEmailsAsync("TestFolder");

        // Assert
        Assert.Equal(5, folderEmails.Count);
        
        _output.WriteLine($"Added {emailIds.Count} emails to folder");
    }

    [Fact]
    public async Task FolderManager_Should_Move_Emails_Between_Folders()
    {
        // Arrange
        await _folderManager.CreateFolderAsync("Source");
        await _folderManager.CreateFolderAsync("Destination");
        
        var bytes = new byte[32];
        BitConverter.GetBytes(6001L).CopyTo(bytes, 0);
        var emailId = new EmailHashedID(bytes);
        await _folderManager.AddEmailToFolderAsync("Source", emailId);

        // Act
        var moveResult = await _folderManager.MoveEmailAsync(emailId, "Source", "Destination");

        // Assert
        Assert.True(moveResult.IsSuccess);
        
        var sourceEmails = await _folderManager.GetEmailsAsync("Source");
        var destEmails = await _folderManager.GetEmailsAsync("Destination");
        
        Assert.Empty(sourceEmails);
        Assert.Single(destEmails);
        Assert.Equal(emailId.Hash, destEmails[0].Hash);
        
        _output.WriteLine("Email moved between folders successfully");
    }

    [Fact]
    public async Task FolderManager_Should_Delete_Folder()
    {
        // Arrange
        await _folderManager.CreateFolderAsync("ToDelete");
        var bytes = new byte[32];
        BitConverter.GetBytes(7001L).CopyTo(bytes, 0);
        var emailId = new EmailHashedID(bytes);
        await _folderManager.AddEmailToFolderAsync("ToDelete", emailId);

        // Act
        var deleteResult = await _folderManager.DeleteFolderAsync("ToDelete");

        // Assert
        Assert.True(deleteResult.IsSuccess);
        
        // Get folder tree to check folders
        var folderTree = await _cacheManager.GetCachedFolderTree();
        var folders = folderTree?.FolderIDs ?? new Dictionary<string, long>();
        Assert.DoesNotContain("ToDelete", folders.Keys);
        
        _output.WriteLine("Folder deleted successfully");
    }

    #endregion

    #region SegmentManager Tests

    [Fact]
    public async Task SegmentManager_Should_Create_And_Retrieve_Segments()
    {
        // Arrange
        var testData = new byte[2048];
        var random = new Random(789);
        random.NextBytes(testData);
        
        var metadata = new Dictionary<string, string>
        {
            ["ContentType"] = "application/octet-stream",
            ["Checksum"] = Convert.ToBase64String(testData.Take(8).ToArray())
        };

        // Act
        var segment = await _segmentManager.CreateSegmentAsync(testData, metadata);
        var retrieved = await _segmentManager.GetSegmentAsync(segment.SegmentId);

        // Assert
        Assert.NotNull(segment);
        Assert.NotNull(retrieved);
        Assert.Equal(testData.Length, retrieved.ContentLength);
        Assert.Equal(testData, retrieved.SegmentData);
        Assert.Equal("application/octet-stream", retrieved.Metadata["ContentType"]);
        
        _output.WriteLine($"Created segment {segment.SegmentId} with {testData.Length} bytes");
    }

    [Fact]
    public async Task SegmentManager_Should_Update_Segment_Data()
    {
        // Arrange
        var originalData = new byte[512];
        new Random(111).NextBytes(originalData);
        var segment = await _segmentManager.CreateSegmentAsync(originalData);
        
        var updatedData = new byte[1024];
        new Random(222).NextBytes(updatedData);

        // Act
        var updated = await _segmentManager.UpdateSegmentAsync(
            segment.SegmentId, 
            updatedData,
            new Dictionary<string, string> { ["UpdatedBy"] = "Test" }
        );

        // Assert
        Assert.Equal(updatedData.Length, updated.ContentLength);
        Assert.Equal(updatedData, updated.SegmentData);
        Assert.Equal(2, updated.Version); // Version should increment
        Assert.Equal("Test", updated.Metadata["UpdatedBy"]);
        
        _output.WriteLine($"Updated segment {segment.SegmentId} to version {updated.Version}");
    }

    [Fact]
    public async Task SegmentManager_Should_Delete_Segments()
    {
        // Arrange
        var data = new byte[64];
        new Random(333).NextBytes(data);
        var segment = await _segmentManager.CreateSegmentAsync(data);

        // Act
        var deleteResult = await _segmentManager.DeleteSegmentAsync(segment.SegmentId);
        var isOutdated = await _segmentManager.IsSegmentOutdatedAsync(segment.SegmentId);

        // Assert
        Assert.True(deleteResult.IsSuccess);
        Assert.True(isOutdated);
        
        _output.WriteLine($"Segment {segment.SegmentId} marked for deletion");
    }

    #endregion

    #region MaintenanceManager Tests - Commented out as MaintenanceManager is not implemented

    // MaintenanceManager tests would go here when the manager is implemented
    // Including:
    // - Cleanup operations
    // - Database integrity validation  
    // - Index rebuilding

    #endregion

    #region End-to-End Email Storage Scenario

    [Fact]
    public async Task Should_Handle_Complete_Data_Storage_Scenario()
    {
        _output.WriteLine("=== Starting Complete Data Storage Scenario ===");

        // Step 1: Create folder structure (folders can represent data categories)
        _output.WriteLine("\nStep 1: Creating data category structure...");
        await _folderManager.CreateFolderAsync("Images");
        await _folderManager.CreateFolderAsync("Documents");
        await _folderManager.CreateFolderAsync("Archive");

        // Step 2: Store data segments
        _output.WriteLine("\nStep 2: Storing data segments...");
        var dataIds = new List<EmailHashedID>(); // Reusing EmailHashedID as a general ID type
        var segments = new List<SegmentContent>();
        var random = new Random(12345);

        for (int i = 1; i <= 15; i++)
        {
            // Create binary data segment of varying sizes
            var dataSize = 1024 * (1 + (i % 5)); // 1KB to 5KB
            var binaryData = new byte[dataSize];
            random.NextBytes(binaryData);
            
            var segment = await _segmentManager.CreateSegmentAsync(
                binaryData,
                new Dictionary<string, string>
                {
                    ["DataType"] = i <= 10 ? "Image" : "Document",
                    ["Size"] = dataSize.ToString(),
                    ["Timestamp"] = DateTime.UtcNow.ToString("O"),
                    ["Checksum"] = Convert.ToBase64String(binaryData.Take(16).ToArray())
                }
            );
            segments.Add(segment);

            // Create ID from segment ID
            var bytes = new byte[32];
            BitConverter.GetBytes(segment.SegmentId).CopyTo(bytes, 0);
            var dataId = new EmailHashedID(bytes);
            dataIds.Add(dataId);

            // Add to appropriate category
            if (i <= 10)
            {
                await _folderManager.AddEmailToFolderAsync("Images", dataId);
            }
            else
            {
                await _folderManager.AddEmailToFolderAsync("Documents", dataId);
            }
        }

        _output.WriteLine($"Stored {dataIds.Count} data segments");

        // Step 3: Move some data to archive
        _output.WriteLine("\nStep 3: Archiving old data...");
        var dataToArchive = dataIds.Take(5).ToList();
        foreach (var dataId in dataToArchive)
        {
            await _folderManager.MoveEmailAsync(dataId, "Images", "Archive");
        }

        // Step 4: Update metadata
        _output.WriteLine("\nStep 4: Updating database metadata...");
        // Update metadata through cache manager
        var metadata = new MetadataContent
        {
            WALOffset = -1,
            FolderTreeOffset = -1,
            SegmentOffsets = new Dictionary<string, long>(),
            OutdatedOffsets = new List<long>()
        };
        
        await _cacheManager.UpdateMetadata(metadata);

        // Step 5: Verify folder contents
        _output.WriteLine("\nStep 5: Verifying category contents...");
        var imageData = await _folderManager.GetEmailsAsync("Images");
        var documentData = await _folderManager.GetEmailsAsync("Documents");
        var archiveData = await _folderManager.GetEmailsAsync("Archive");

        Assert.Equal(5, imageData.Count);
        Assert.Equal(5, documentData.Count);
        Assert.Equal(5, archiveData.Count);

        // Step 6: Delete some data
        _output.WriteLine("\nStep 6: Deleting old archived data...");
        var dataToDelete = archiveData.Take(2).ToList();
        foreach (var dataId in dataToDelete)
        {
            await _folderManager.RemoveEmailFromFolderAsync("Archive", dataId);
            
            // Mark corresponding segment as outdated
            // Extract segment ID from EmailHashedID
            var hashBytes = dataId.GetBytes();
            var segmentId = BitConverter.ToInt64(hashBytes, 0);
            await _segmentManager.DeleteSegmentAsync(segmentId);
        }

        // Step 7: Perform maintenance
        _output.WriteLine("\nStep 7: Performing maintenance...");
        // await _maintenanceManager.PerformCleanupAsync();
        // await _maintenanceManager.RebuildIndexesAsync();
        _output.WriteLine("(MaintenanceManager operations skipped - not implemented)");

        // Step 8: Final verification
        _output.WriteLine("\nStep 8: Final verification...");
        var finalArchiveData = await _folderManager.GetEmailsAsync("Archive");
        Assert.Equal(3, finalArchiveData.Count);

        var finalMetadata = await _metadataManager.GetMetadataAsync();
        Assert.NotNull(finalMetadata);

        // var integrityCheck = await _maintenanceManager.ValidateDatabaseIntegrityAsync();
        // Assert.True(integrityCheck.IsSuccess);
        _output.WriteLine("(Integrity check skipped - MaintenanceManager not implemented)");

        _output.WriteLine($"\n=== Data Storage Scenario Complete ===");
        _output.WriteLine($"Final database size: {new FileInfo(_testFile).Length:N0} bytes");
        _output.WriteLine($"Total blocks: {_rawBlockManager.GetAllBlockLocations().Count}");
    }

    #endregion

    public void Dispose()
    {
        // _maintenanceManager?.Dispose();
        _segmentManager?.Dispose();
        _folderManager?.Dispose();
        _metadataManager?.Dispose();
        _cacheManager?.Dispose();
        _rawBlockManager?.Dispose();

        if (Directory.Exists(_testDirectory))
        {
            try
            {
                Directory.Delete(_testDirectory, true);
            }
            catch
            {
                // Best effort cleanup
            }
        }
    }
}